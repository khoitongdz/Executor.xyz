<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dead Rails</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #222; }
    canvas { display: block; }
    #pause-button {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      background: #0a0;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 18px;
      z-index: 1000;
      display: none;
    }
    #pause-button:hover {
      background: #0c0;
    }
  </style>
</head>
<body>
  <button id="pause-button" onclick="togglePause()">Pause</button>
<script>
let playerX, playerY;
let obstacles = [];
let powerUps = [];
let particles = [];
let clouds = [];
let trees = [];
let score = 0;
let highScore = localStorage.getItem('highScore') ? parseInt(localStorage.getItem('highScore')) : 0;
let gameState = 'menu';
let lanes;
let speed = 5;
let bgY = 0;
let shieldActive = false;
let shieldTimer = 0;
let shakeTimer = 0;
let shakeOffsetX = 0;
let shakeOffsetY = 0;
let targetLane;

function setup() {
  createCanvas(windowWidth, windowHeight);
  lanes = [width * 0.3, width * 0.5, width * 0.7];
  playerX = lanes[1];
  playerY = height - height * 0.2;
  targetLane = lanes[1];
  for (let i = 0; i < 5; i++) {
    clouds.push({
      x: random(width),
      y: random(height * 0.1, height * 0.3),
      size: random(50, 100)
    });
  }
  for (let i = 0; i < 10; i++) {
    trees.push({
      x: random(width),
      y: random(height * 0.4, height * 0.8)
    });
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  lanes = [width * 0.3, width * 0.5, width * 0.7];
  playerX = lanes[1];
  playerY = height - height * 0.2;
  targetLane = lanes[1];
}

function draw() {
  if (shakeTimer > 0) {
    shakeOffsetX = random(-5, 5);
    shakeOffsetY = random(-5, 5);
    shakeTimer--;
    translate(shakeOffsetX, shakeOffsetY);
  }

  if (gameState === 'menu') {
    drawBackground();
    fill(255);
    textSize(width * 0.08);
    textAlign(CENTER);
    text("Dead Rails", width / 2, height / 2 - height * 0.1);
    fill(0, 200, 0);
    rect(width / 2 - width * 0.12, height / 2, width * 0.24, height * 0.08, 10);
    fill(255);
    textSize(width * 0.04);
    text("Start Game", width / 2, height / 2 + height * 0.05);
    document.getElementById('pause-button').style.display = 'none';
  } else if (gameState === 'playing') {
    document.getElementById('pause-button').style.display = 'block';
    document.getElementById('pause-button').textContent = 'Pause';
    
    drawBackground();
    drawRails();

    // Di chuyển nhân vật
    updatePlayerMovement();
    playerX = lerp(playerX, targetLane, 0.2); // Tăng tốc độ lerp cho mượt hơn

    drawPlayer();

    if (shieldActive) {
      if (frameCount > shieldTimer) {
        shieldActive = false;
      } else {
        noFill();
        stroke(255, 215, 0, 200);
        strokeWeight(3);
        ellipse(playerX, playerY, width * 0.12, width * 0.12);
        noStroke();
      }
    }

    let obstacleFrequency = 60 - floor(score / 200);
    obstacleFrequency = max(obstacleFrequency, 30);
    if (frameCount % obstacleFrequency === 0) {
      let lane = lanes[floor(random(3))];
      obstacles.push({ x: lane, y: -height * 0.06 });
    }

    for (let i = obstacles.length - 1; i >= 0; i--) {
      obstacles[i].y += speed;
      fill(0, 0, 0);
      rect(obstacles[i].x - width * 0.05, obstacles[i].y - width * 0.05, width * 0.1, width * 0.1, 5);
      fill(169, 169, 169);
      ellipse(obstacles[i].x - width * 0.03, obstacles[i].y - width * 0.03, width * 0.02, width * 0.02);
      ellipse(obstacles[i].x + width * 0.03, obstacles[i].y - width * 0.03, width * 0.02, width * 0.02);
      ellipse(obstacles[i].x - width * 0.03, obstacles[i].y + width * 0.03, width * 0.02, width * 0.02);
      ellipse(obstacles[i].x + width * 0.03, obstacles[i].y + width * 0.03, width * 0.02, width * 0.02);

      if (!shieldActive && dist(playerX, playerY, obstacles[i].x, obstacles[i].y) < width * 0.08) {
        gameState = 'gameOver';
        shakeTimer = 10;
        break;
      }

      if (obstacles[i].y > height + height * 0.06) {
        obstacles.splice(i, 1);
      }
    }

    if (frameCount % 180 === 0) {
      let lane = lanes[floor(random(3))];
      powerUps.push({ x: lane, y: -height * 0.06, type: 'shield' });
    }

    for (let i = powerUps.length - 1; i >= 0; i--) {
      powerUps[i].y += speed;
      fill(255, 215, 0, 200);
      ellipse(powerUps[i].x, powerUps[i].y, width * 0.06, width * 0.06);
      fill(0, 0, 255);
      textAlign(CENTER);
      textSize(width * 0.03);
      text("S", powerUps[i].x, powerUps[i].y + width * 0.01);

      if (dist(playerX, playerY, powerUps[i].x, powerUps[i].y) < width * 0.06) {
        if (powerUps[i].type === 'shield') {
          shieldActive = true;
          shieldTimer = frameCount + 300;
        }
        powerUps.splice(i, 1);
        continue;
      }

      if (powerUps[i].y > height + height * 0.06) {
        powerUps.splice(i, 1);
      }
    }

    if (frameCount % 5 === 0) {
      particles.push({
        x: playerX - width * 0.04,
        y: playerY - height * 0.08,
        vx: random(-1, 1),
        vy: random(-2, -1),
        life: 60
      });
    }

    for (let i = particles.length - 1; i >= 0; i--) {
      let p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.life -= 1;
      fill(200, 200, 200, p.life * 4);
      noStroke();
      ellipse(p.x, p.y, width * 0.02, width * 0.02);
      if (p.life <= 0 || particles.length > 50) {
        particles.splice(i, 1);
      }
    }

    speed = min(5 + score / 1000, 10);
    score += 1;

    fill(255);
    textSize(width * 0.04);
    textAlign(LEFT);
    text("Score: " + floor(score / 10), width * 0.02, height * 0.06);
    textAlign(RIGHT);
    text("High Score: " + highScore, width - width * 0.02, height * 0.06);
  } else if (gameState === 'gameOver') {
    document.getElementById('pause-button').style.display = 'none';
    if (floor(score / 10) > highScore) {
      highScore = floor(score / 10);
      localStorage.setItem('highScore', highScore);
    }
    drawBackground();
    fill(255, 0, 0, 200);
    rect(0, 0, width, height);
    fill(255);
    textSize(width * 0.08);
    textAlign(CENTER);
    text("Game Over!", width / 2, height / 2 - height * 0.1);
    textSize(width * 0.05);
    text("Score: " + floor(score / 10), width / 2, height / 2);
    text("High Score: " + highScore, width / 2, height / 2 + height * 0.06);
    fill(0, 200, 0);
    rect(width / 2 - width * 0.12, height / 2 + height * 0.1, width * 0.24, height * 0.08, 10);
    fill(255);
    textSize(width * 0.04);
    text("Play Again", width / 2, height / 2 + height * 0.15);
    noLoop();
  } else if (gameState === 'paused') {
    drawBackground();
    fill(0, 0, 0, 200);
    rect(0, 0, width, height);
    fill(255);
    textSize(width * 0.08);
    textAlign(CENTER);
    text("Paused", width / 2, height / 2);
    document.getElementById('pause-button').style.display = 'block';
    document.getElementById('pause-button').textContent = 'Resume';
    noLoop();
  }

  if (shakeTimer <= 0) {
    translate(0, 0);
  }
}

function updatePlayerMovement() {
  // Chuột
  if (mouseX >= 0 && mouseX <= width) {
    if (mouseX < width / 3) targetLane = lanes[0];
    else if (mouseX < 2 * width / 3) targetLane = lanes[1];
    else targetLane = lanes[2];
  }
  // Cảm ứng
  if (touches.length > 0) {
    let touchX = touches[0].x;
    if (touchX < width / 3) targetLane = lanes[0];
    else if (touchX < 2 * width / 3) targetLane = lanes[1];
    else targetLane = lanes[2];
  }
}

function keyPressed() {
  if (gameState === 'playing') {
    if (keyCode === LEFT_ARROW && laneIndex(playerX) > 0) {
      targetLane = lanes[laneIndex(playerX) - 1];
    } else if (keyCode === RIGHT_ARROW && laneIndex(playerX) < 2) {
      targetLane = lanes[laneIndex(playerX) + 1];
    } else if (key === ' ') {
      togglePause();
    }
  }
}

function touchMoved() {
  if (gameState === 'playing' && touches.length > 0) {
    let touchX = touches[0].x;
    if (touchX < width / 3) targetLane = lanes[0];
    else if (touchX < 2 * width / 3) targetLane = lanes[1];
    else targetLane = lanes[2];
  }
  return false;
}

function touchStarted() {
  if (gameState === 'playing' && touches.length > 0) {
    let touchX = touches[0].x;
    if (touchX < width / 3) targetLane = lanes[0];
    else if (touchX < 2 * width / 3) targetLane = lanes[1];
    else targetLane = lanes[2];
  }
  mousePressed();
  return false;
}

function laneIndex(x) {
  return lanes.indexOf(lanes.reduce((a, b) => Math.abs(b - x) < Math.abs(a - x) ? b : a));
}

function mousePressed() {
  if (gameState === 'menu') {
    let buttonX = width / 2 - width * 0.12;
    let buttonY = height / 2;
    if (mouseX > buttonX && mouseX < buttonX + width * 0.24 && mouseY > buttonY && mouseY < buttonY + height * 0.08) {
      resetGame();
      gameState = 'playing';
      loop();
    }
  } else if (gameState === 'gameOver') {
    let buttonX = width / 2 - width * 0.12;
    let buttonY = height / 2 + height * 0.1;
    if (mouseX > buttonX && mouseX < buttonX + width * 0.24 && mouseY > buttonY && mouseY < buttonY + height * 0.08) {
      resetGame();
      gameState = 'playing';
      loop();
    }
  }
}

function togglePause() {
  if (gameState === 'playing') {
    gameState = 'paused';
    document.getElementById('pause-button').textContent = 'Resume';
  } else if (gameState === 'paused') {
    gameState = 'playing';
    document.getElementById('pause-button').textContent = 'Pause';
    loop();
  }
}

function resetGame() {
  obstacles = [];
  powerUps = [];
  particles = [];
  clouds = [];
  trees = [];
  score = 0;
  speed = 5;
  playerX = lanes[1];
  targetLane = lanes[1];
  shieldActive = false;
  shakeTimer = 0;
  for (let i = 0; i < 5; i++) {
    clouds.push({
      x: random(width),
      y: random(height * 0.1, height * 0.3),
      size: random(50, 100)
    });
  }
  for (let i = 0; i < 10; i++) {
    trees.push({
      x: random(width),
      y: random(height * 0.4, height * 0.8)
    });
  }
}

function drawBackground() {
  for (let y = 0; y < height * 0.5; y++) {
    let c = lerpColor(color(135, 206, 235), color(0, 0, 50), y / (height * 0.5));
    stroke(c);
    line(0, y, width, y);
  }
  fill(34, 139, 34);
  rect(0, height * 0.5, width, height * 0.5);

  fill(100, 100, 100);
  triangle(width * 0.2, height * 0.5, width * 0.4, height * 0.3, width * 0.6, height * 0.5);
  triangle(width * 0.7, height * 0.5, width * 0.9, height * 0.35, width * 1.1, height * 0.5);

  for (let cloud of clouds) {
    cloud.x -= 0.5;
    if (cloud.x < -cloud.size) cloud.x = width + cloud.size;
    fill(255, 255, 255, 200);
    noStroke();
    ellipse(cloud.x, cloud.y, cloud.size, cloud.size * 0.6);
    ellipse(cloud.x + cloud.size * 0.3, cloud.y - cloud.size * 0.2, cloud.size * 0.7, cloud.size * 0.5);
  }

  for (let tree of trees) {
    tree.y += speed * 0.5;
    if (tree.y > height + height * 0.1) tree.y = -height * 0.1;
    fill(139, 69, 19);
    rect(tree.x - width * 0.01, tree.y - height * 0.06, width * 0.02, height * 0.06);
    fill(0, 100, 0);
    ellipse(tree.x, tree.y - height * 0.08, width * 0.06, width * 0.06);
  }
}

function drawRails() {
  for (let lane of lanes) {
    stroke(100);
    strokeWeight(width * 0.008);
    line(lane, 0, lane, height);
    for (let y = bgY; y < height; y += height * 0.05) {
      fill(139, 69, 19);
      noStroke();
      rect(lane - width * 0.05, y - height * 0.01, width * 0.1, height * 0.02);
      fill(169, 169, 169);
      ellipse(lane - width * 0.04, y, width * 0.008, width * 0.008);
      ellipse(lane + width * 0.04, y, width * 0.008, width * 0.008);
    }
  }
  bgY = (bgY + speed) % (height * 0.05);
}

function drawPlayer() {
  for (let r = width * 0.1; r > 0; r -= 5) {
    fill(255, 215, 0, 10);
    noStroke();
    ellipse(playerX, playerY, r, r);
  }
  fill(0, 100, 200);
  rect(playerX - width * 0.05, playerY - height * 0.08, width * 0.1, height * 0.16, 10);
  fill(200, 0, 0);
  rect(playerX - width * 0.05, playerY - height * 0.08, width * 0.1, height * 0.04, 5);
  fill(255);
  rect(playerX - width * 0.03, playerY - height * 0.06, width * 0.02, height * 0.02);
  rect(playerX + width * 0.01, playerY - height * 0.06, width * 0.02, height * 0.02);
  fill(0);
  ellipse(playerX - width * 0.03, playerY + height * 0.06, width * 0.04, width * 0.04);
  ellipse(playerX + width * 0.03, playerY + height * 0.06, width * 0.04, width * 0.04);
}
</script>
</body>
</html>
